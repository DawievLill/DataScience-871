---
title: "Data Science for Economics and Finance"
subtitle: "Lecture 6: Functions and more"
author:
  name: Dawie van Lill (dvanlill@sun.ac.za) | [Github](https://github.com/DawievLill)
  date: Lecture 3 "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    theme: cosmo
    highlight: pygments
always_allow_html: true
urlcolor: blue
mainfont: cochineal
sansfont: Fira Sans
monofont: Fira Code 
---

<style type="text/css">
  body{
  font-size: 14pt;
}
</style>

```{r setup, include=FALSE}

options(htmltools.dir.version = FALSE)

library(knitr)
opts_chunk$set(
  prompt = T, ## See hook below. I basically want a "$" prompt for every bash command in this lecture.
  fig.align="center", #fig.width=6, fig.height=4.5, 
  # out.width="748px", #out.length="520.75px",
  dpi=300, #fig.path='Figs/',
  cache=F#, echo=F, warning=F, message=F
  )

## Next hook based on this SO answer: https://stackoverflow.com/a/39025054
knit_hooks$set(
  prompt = function(before, options, envir) {
    options(
      prompt = if (options$engine %in% c('sh','bash')) '$ ' else 'R> ',
      continue = if (options$engine %in% c('sh','bash')) '$ ' else '+ '
      )
})
```


# References

The primary references for today's discussion can be found [here](https://stat545.com/functions-part1.html) and  [here](https://style.tidyverse.org/functions.html). The latter reference provides a more advanced walkthrough on functions than we are exploring here. It is the natural next place to go to learn more about functions. 

Once again, most of the material that we will cover for the next few weeks is **heavily** influenced by the amazing lecture notes by Grant McDermott. You can visit his [Github page](https://github.com/uo-ec607/lectures) for more information.  

# Packages

Run this piece of code to ensure that you have the appropriate packages installed for the session to follow. 

```{r, cache=F, message=F}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(pbapply, tidyverse, gapminder, assertthat)
```

# Introduction

We have covered a lot of work with the `shell` and `Julia`. Now it is time to get back to using `R`. We will be covering some topics that you have encountered with Nico and some that overlap with the `Julia` lectures. You can see this lecture as a bit of revision, to refocus your attention on `R`. 

The ideas behind functions and functional programming were covered with Nico in the first part of the course. This section is an extension (revision) of the functionality that Nico introduced and also a precursor to the parallel programming lecture that follows this one. We focus our attention on how to write functions and the related ideas in functional programming (especially as it applies to iteration).

This section also serves as a review of user-built functions, an important topic in its own right. Powerful packages such as `dplyr`, `purrr`, and the `apply` famlily of functions are ready and waiting to apply your purpose-built functions to various components of your data. It is important that you are able to express yourself through functions, since these tools will provide great power. 


# Functions

You have already dealt with several functions in R. Some of them come pre-packaged with base R (e.g. `mean()`), while others are from external packages (e.g. `dplyr::filter()`). Functions in R all have the same basic syntax:

```r
function_name(ARGUMENTS)
```
Most of the time we use functions written by other people. However, as you know by now, you can write your own functions too. This is easy to do with the generic **`function()`** function. The syntax will again look familiar to you:

```r
function(ARGUMENTS) {
  OPERATIONS
  return(VALUE)
}
```

While we can write anonymous functions like the one above, we typically write functions because we want to reuse code. For this typical use-case it makes sense to name our functions. You can use either `=` or `<-` when assigning the function name. Try to give functions names that make sense to other people reading your code. 

```r
my_func =
  function(ARGUMENTS) {
    OPERATIONS
    return(VALUE)
  }
```

This function can be written across multiple lines as above, or it can be stated in a single line as follows, 

```r
my_short_func = function(ARGUMENTS) OPERATION
```

We will illustrate with some examples below. 

## Example: Gapminder data

We can write functions to more easily work with data. We might have some interactive code that we want to wrap in a function. My general advice is that you always want to wrap your code in functions if you can. 

Say that we have the following interactive code that we input into our console, 


```{r gap_1}
min(gapminder$lifeExp)
```

```{r gap_2}
max(gapminder$lifeExp)
```

We want to calculate the difference between the maximum and minimum life expectancy in the Gapminder dataset. 

```{r gap_3}
max(gapminder$lifeExp) - min(gapminder$lifeExp)
```

One nice thing to do is to wrap this in a function, so that we can perhaps use this difference operator for other variables as well. We can write the function on one line as follows, 

```{r gap_4}
max_minus_min <- function(x) max(x) - min(x)
```

We can test this function on our Gapminder data, but also on other inputs. 

```{r gap_5}
max_minus_min(gapminder$lifeExp)
```

```{r gap_6}
max_minus_min(gapminder$gdpPercap)
```

```{r gap_7}
max_minus_min(1:10)
```

```{r gap_8}
max_minus_min(runif(1000))
```

This function will only work for certain types of inputs where `max()` and `min()` make sense. If we were to try the following it wouldn't work, 

```r
R> max_minus_min(gapminder$country) # What is the max() and min() of the country variable?
```

```
## [1] Error in Summary.factor(structure(c(1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, : 'max' not meaningful for factors
```

The function provides us the power to apply a general method to many different inputs. Remember, computer scientists are a lazy bunch, they don't want to write out the same piece of code multiple times! We don't want to repeat ourselves and create more effort than necessary. So when you are writing code, always think about wrapping it in a function. There are obviously many other benefits to writing in terms of functions, such as retaining local scope instead of working with global variables. I am sure that Nico covered some of the basic ideas of why function are so important.  

In `R` it is often useful to write a function in its own script. This is generally good programming practice. In other languages like `Julia` this is not necessarily the same. If we have time I can go over how efficient `Julia` code looks. 

### **Warning**: Type stability 

There are going to be some cases where the function works, but it isn't what we intended. This means that we have to be careful to consider potential fringe cases and the types of variables that can be input into the function.  

```{r gap_9}
max_minus_min(c(TRUE, TRUE, FALSE, TRUE, TRUE))
```

> **Note**: This is where `Julia` really shines, it's type annotation system allows you to finely control which types of variables are acceptable as inputs into the function. 

As far as I am aware, since `R` is a dynamically typed language (the type is inferred by the compiler), you can get some weird results sometimes when writing functions. For example, what does the following function do?

```{r gap_10}
do_magic <- 
  function(a, b) {
	a + b
}
```

If we are summing two numbers then this makes sense. However, this will also add two Booleans! Is this what we intended the function to do? In Julia you could write a function as follows, 

```julia
function do_magic(a::Number, b::Number)
  return a + b
end
```

In this case the function will not work with something other than a `Number`, since we declared that the inputs into the function should be of a certain abstract type. This is perhaps a bit more technical of a topic, but writing type stable code is important in production. In the case of `R` your code should be well documented and should make people aware of the possibility of potential output conflicts for specific inputs. I am not aware of an elegant solution to resolve the issues with a dynamically typed language such as `R`, but maybe someone who is more of an expert in the language such as Nico might have a good answer. 

One solution that I have found is to call a `stopifnot()` function inside of your function

```{r gap_11}
do_magic_type_stable <- 
  function(a, b) {
  stopifnot(is.numeric(a))
  stopifnot(is.numeric(b))
	a + b
}
```

```{r gap_13}
do_magic(1, 2)
```

```{r gap_14}
do_magic(TRUE, FALSE)
```

```{r gap_15}
do_magic_type_stable(1, 2)
```

```r
do_magic_type_stable(TRUE, FALSE)
```

```
## [1] Error in do_magic_type_stable(TRUE, FALSE) : is.numeric(a) is not TRUE
```

If you want a clearer error message you can use the `assertthat` package instead of `stopifnot()`.

```{r gap_16}
do_magic_assert <- 
  function(a, b) {
  assert_that(is.numeric(a))
  assert_that(is.numeric(b))
	a + b
}
```

```r
do_magic_assert(TRUE, FALSE)
```

```
## [1] Error: a is not a numeric or integer vector
```

However, this is not a natural solution and is not as flexible as `Julia` when it comes to type specification. If you want to know more about how to protect the functions you wrote from providing nonsense output I recommend you read the section on **defensive programming** by Hadley Wickham in his textbook called *Advanced R*. You can find a link to the chapter [here](http://adv-r.had.co.nz/Exceptions-Debugging.html#defensive-programming). 

## Example: The cube

You should already have written some of your own functions, but as a quick reminder. Let us write a function that returns the cube of some input number.

```{r cube1}
cube =              ## Our function name
  function(x) {     ## The argument(s) that our function takes as an input
    x^3             ## The operation(s) that our function performs
  }
```

We can test whether this function works. Fingers crossed!

```{r cube 1a}
cube(3)
```

If my math is correct, it should be the case that $3^3$ is equal to $27$. So the function seems to be doing its job. In general we wouldn't write functions as simple as these, since they most likely already exist in base `R` (just look at the arithmetic functions in `R`) and will be more efficiently coded. However, in some cases we will need to write our own functions. 

In our example above we didn't specify the `return` value in the code block. This is because `R`, like many other programming languages, automatically returns the final object in that you created with the function. However, I believe it is good practice to always assign return objects (as opposed to what Hadley Wickham says about `return` functions [here](https://style.tidyverse.org/functions.html)).

```{r cube2}
cube =              
  function(x) {     
    x_cub = x^3     ## Create an intermediary object (that will be returned)
    return(x_cub)   ## The value(s) or object(s) that we want returned.    
  }
```

Specifying a return value is also helpful when we want to return more than one object. For example, let's say that we want to remind our user what variable they used as an argument in our function:

```{r cube3}
cube = 
  function(x) {     ## The argument(s) that our function takes as an input
    x_cub = x^3     ## The operation(s) that our function performs
    return(list(value = x, value_cubed = x_cub)) ## The list of object(s) that we want returned.
  }
```

If we have multiple return objects we have to combine them in a list.  Remember that many objects in `R` `contain multiple elements (vectors, data frames, and lists are all good examples of this). So we can also specify one of these "array"-type objects within the function itself if that provides a more convenient form of output. For example, we could combine the input and output values into a data frame:

```{r cube4}
cube = 
  function(x) { 
    x_cub = x^3 
    df = tibble(value = x, value_cubed = x_cub) ## Bundle up our input and output values into a convenient dataframe.
    return(df)
  }
```

### Default argument values

Another thing worth noting about R functions is that you can assign default argument values.

```{r cube5}
cube = 
  function(x = 1) { ## Setting the default argument value 
    x_cub = x^3 
    df = tibble(value=x, value_cubed = x_cub)
    return(df)
  }
```

```{r cube6}
cube() ## Will take the deafult value of 1
```

```{r cube7}
cube(2) ## Now takes the explicit value that we give it.
```

## Lexical scoping

An important concept to understand in the discussion of functions is the idea of lexical scoping. If you enter the code for this session into the console you will see that the functions will have entered the global enironment. However, the variables such as `x` inside of the function haven't creeped into the global environment. These variables can only be accessed within the function itself (locallly). 

You can think of a function as its own environment. They only return objects to the global environment when they are forced to, normally with a `return()` command. The function will also only look outside of its own scope for a variable if it isn't defined in the function body. We will talk about this a bit more in the section on functional programming. I am sure Nico has mentioned this before, I just want to reiterate the point here. 

# Control flow

# Iteration

# Functional programming



































